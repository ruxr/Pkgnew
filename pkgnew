#!/bin/sh
DB=/var/lib/pkg/db
DIR=/usr/ports
WRK=$DIR/CRUX
CFG=$WRK/PKG.cfg
NEW="Update and build CRUX packages

	@(#) pkgnew V1.19 (C) 2019 by Roman Oreshnikov

	This is free software, and comes with NO WARRANTY

Usage: pkgnew [options] [port ...]

Options:
  -b  Build and install packages
  -e  Edit working Pkgfile
  -h  Display this text
  -i  Information about specified packages or a list of possible unused ports
  -l  List of files that do not belong to installed packages
  -p  Show differences between original and used Pkgfile
  -u  Update the port collections
  -z  Delete unused source files and packages after build

Report bugs to <r.oreshnikov@gmail.com>"
#
# Common subroutines
#
Wrn() { echo "\rpkgnew: $*" >&2; }
Msg() { case $1 in [A-Z]*) echo $*;; *) echo \	$*;; esac >&2; }
Inf() { echo "======> $*"; }
Lst() { sed "\${x;s/\n/ /g;q};/\//d;/^$/d;/^lib64/d;N;s/\n$1/;H;d" $DB; }
End() {
	trap 0
	[ -s "$LOG" ] && Wrn Last 10 lines of hidden output && tail $LOG >&2
	[ -z $TMP ] || rm -r $TMP
	[ $# = 0 ] && exit || Wrn $*
	exit 1
}
Ask() {
	[ $# = 0 ] && A="Press Enter for continue" || A="$*? [N/y]"
	read -p "pkgnew: $A " A
	case $A in ''|[!Yy]*) return 1;; esac
}
#
# CreateBuildList subrouitines
#
PortPkgfile() { # Repo Port Pkgfile [Flag]
	N=./Pkgfile S=
	if [ -z $4 ]; then
		N=$TMP/$2
		if ! cp -p $3 $N; then
			echo % copy error; exit
		elif [ -f $WRK/$2 ]; then
			if [ ! $WRK/$2 -nt $3 ]; then
				echo % old patch for; exit
			elif ! patch -fi $WRK/$2 $N >/dev/null; then
				echo % failed to patch; exit
			fi
			touch -r $WRK/$2 $N
			S=p
		fi
		for F in $WRK/$2#*; do
			[ -f $F -a $F -nt $N ] && touch -r $F $N
		done
		[ -f $F ] && S=a$S
	fi
	bash -c "cd $DIR/$1/$2; . $N
		if [ \$? != 0 ]; then	:
		elif [ -z \"\$name\" ]; then	echo - name
		elif [ -z \"\$version\" ]; then	echo - version
		elif [ -z \"\$release\" ]; then	echo - release
		elif [ \"x$2\" != \"x\$name\" ]; then echo = name \"\$name\"
		elif [ X\$(type -t build) != Xfunction ]; then echo + build
		else	echo \$version-\$release -$S \${source[@]}
		fi" 2>/dev/null
}
PortOptions() { # ...
	echo $*
	V=$D/$P#$1
	L=$(sed '/^# Build also:/!d;s/.*://;s/[ \t]#.*//;q' $TMP/$P)
	for S in $L; do
		case " $A " in
		*\ $S\ *) echo " port '$S' declared before definition in $F";;
		*) A=$A\ $S; echo Pkg $S
		esac
	done
	L=$(sed '/^# Depends on/!d;s/.*://;s/,/ /g;s/[ \t]#.*//;q' $TMP/$P)
	[ -z "$L" ] || { N=$N\ $L; echo Dep $L; }
	sed -n 's/^# Post-install:/Run/p;s/^# Required user:/Who/p' $TMP/$P
}
PortCheck() {
	F=$DIR/$D/$P/Pkgfile
	[ -f $F ] || return 0
	set -- $(PortPkgfile $D $P $F $V)
	case $1 in
	'')	echo " runtime error $F";;
	%)	shift; echo " $* $F";;
	+)	echo " function '$2' not specified in $F";;
	-)	echo " variable '$2' not specified in $F";;
	=)	echo " variable '$2' has bad value '$3' in $F";;
	*)	[ -n "$V" ] && echo " $V <?> $D/$P#$1" || PortOptions $P $D $*
	esac
}
PortsList() { # Port ...
	A=ALL
	while [ $# != 0 ]; do
		N=
		for P do
			case " $A " in *\ $P\ *) continue;; esac
			V= A=$A\ $P
			for D in $USE; do PortCheck; done
			[ -n "$V" ] || echo Bad $P
		done
		set -- $N
	done
}
PortsOrder() {
	awk '
	function Err(s) { E = 1; print "\t" s >"/dev/stderr" }
	function Reg(i) { if(!(i in u)) l = l Dep[u[i] = i] }
	function Out(n, a, i) {
		split(Dep[n], a)
		for(i in a) if(a[i] in Val) return 0
		if(n != "ALL") {
			if(n in Who) print "Who", n Who[n]
			print "Pkg", Val[n], n Pkg[n] Src[n] " #" Dep[n]
		}
		delete Val[n]
		return 1
	}
	/^$/ { exit 2 }
	/^ / { Err($0); next }
	/^Bad/ { Bad[$2] = ""; next }
	/^Dep/ { Dep[n] = substr($0, 4); next }
	/^Pkg/ { Pkg[n] = substr($0, 4) Pkg[n]; next }
	/^Run/ { Pkg[n] = Pkg[n] "r"; next }
	/^Who/ { Who[n] = substr($0, 4); next }
	{
		Ord[++i] = n = $1; Val[n] = $2 " " $3; Pkg[n] = " " $4
		sub(/^.+ -[^ ]*/, ""); Src[n] = $0
	}
	END {
		if(E) exit 1
		for(n in Val) {
			delete s; split(Dep[n], a)
			for(i in a) s[a[i]] = a[i]
			if("ALL" in s) ALL[n] = 0
			delete s[n]
			do {
				l = ""
				for(j in s) {
					if(j in Bad) Bad[j] = Bad[j] " " n
					delete u; u[n] = l = j
					while(split(l, a)) {
						l = ""; for(i in a) Reg(a[i])
					}
					delete u[j]
					for(i in s) if(i in u) delete s[l = i]
					if(l) break
				}
			} while(l)
			asort(s); for(i in s) l = l " " s[i]
			Dep[n] = l
		}
		for(n in Bad) b[n] = n
		asort(b)
		for(n in b) {
			n = b[n]
			if(Bad[n] != "") Bad[n] = ", required for" Bad[n]
			Err("port " n " not found" Bad[n])
		}
		if(E) exit 1
		l = ""
		for(i in Val) if(!(i in ALL)) l = l " " i
		Dep[Ord[n] = Val[n] = n = "ALL"] = l
		asort(Ord)
		do {
			n = 0; for(i in Ord) if(Out(Ord[i])) delete Ord[n = i]
		} while(n)
		if(asort(Ord)) {
			Err("Errors in dependency order:")
			for(i in Ord)
				Err("  port " Ord[i] " require" Dep[Ord[i]])
			exit 1
		}
	}'
}
#
# BuildPackages subroutines
#
NewPackages() {
	SRC=$PKGMK_WORK_DIR/$P/src PKG=${SRC%/*}/pkg
	rm -rf ${SRC%/*}
	mkdir -p $SRC $PKG
	cd ${SRC%/*}
	Inf Upload missing files
	for S do
		case $S in
		*/*)	F=$PKGMK_SOURCE_DIR/${S##*/}
			[ -f $F ] || { wget -cO $F.part $S && mv $F.part $F; }
		esac
	done
	Inf Verify source files
	for F in Pkgfile .footprint $*; do
		case $F in
		*/*)	F=$PKGMK_SOURCE_DIR/${F##*/};;
		*)	F=$D/$F
		esac
		ln -s $F .
	done
	if [ -f $D/.signature ]; then
		F=/etc/ports/$G.pub
		[ -s $F ] && F=-p\ $F || F=
		signify -qCx $D/.signature $F
	fi
	cd $D
	Inf Build the main package
	bash -c "
	unpack_source() {
		local F
		for F in \${source[@]}; do
			case \$F in */*) F=\$PKGMK_SOURCE_DIR/\${F##*/};; esac
			case \$F in
			*.tar.[glx]z|*.tar.bz2|*.tar.Z|*.tar.lzma|*.tar| \
			*.t[gx]z|*.tbz2|*.zip|*.rpm|*.7z)
				bsdtar -C \$SRC -opxf \$F || exit;;
			*)	cp \$F \$SRC
			esac
		done
	}
	[ -f .32bit ] && PKGMK_ARCH=32 || PKGMK_ARCH=64
	. $TMP/$P
	. /etc/pkgmk.conf
	SRC=$SRC PKG=$PKG
	unpack_source
	for F in $U $WRK/$P#*; do [ ! -f \$F ] || cp \$F $SRC/\${F#*#}; done
	cd $SRC
	set -ex
	build"
	cd $PKG
	Inf Remove unnecessary information from strippable files
	S=$D/.nostrip
	[ -f $S ] && S="grep -vf $S" || S=cat
	find . -type f -printf "%P\n" | $S |
	while read F; do
		case $(file -b $F) in
		*ELF*executable*not\ stripped*) S=--strip-all;;
		*ELF*shared\ object*not\ stripped*) S=--strip-unneeded;;
		current\ ar\ archive) S=--strip-debug;;
		*) continue
		esac
		strip $S $F
	done
	Inf Compress man pages
	find . -type f -path "*/man/man*/*" ! -name "*.gz" -exec gzip -9 {} \;
	find . -type l -path "*/man/man*/*" ! -name "*.gz" |
	while read F; do ln -sf $(readlink -n $F).gz $F.gz && rm $F; done
	cd ..
	mv -T --backup=t pkg $P
	if [ "x$L" != "x $P" ]; then
		Inf Create additional packages
		bash -c ". $TMP/$P; set -ex; buildalso"
	fi
	Inf Create packages
	[ -z $U ] || install -m644 $SRC/$U $PKGMK_PACKAGE_DIR/$P#$V.$U
	for F in $L; do
		echo $F >>$PKGMK_PACKAGE_DIR/PKG.ldd
		cd $F; bsdtar -caf ../$F#$V$EXT *; cd ..
	done
	mv *#$V$EXT $PKGMK_PACKAGE_DIR
	cd /
	rm -rf ${SRC%/*}
}
Pkg() { # Repo Ver-Rel Pkg ... -[apr] [Src ...]
	G=$1 V=$2 P=$3 D=$DIR/$1/$3
	N=$(sed "/^$P$/{N;s/^.*\n//;q};d" $DB)
	case /$N/ in
	/$V/)	N=;;
	//)	N=y;;
	*)	[ "x${N%-[0-9]*}" = "x${V%-[0-9]*}" ] && V=$N N= || N=y
	esac
	I= L= U=
	shift 2
	while [ -z "$I" ]; do
		case $1 in
		-*)	case $1 in *a*) I=$I\ add-ons;; esac
			case $1 in *p*) I=$I\ patch;; esac
			case $1 in
			*r) U=post-install I=$I\ $U F=$P#$V.$U;;
			*) shift; break
			esac;;
		*)	L=$L\ $1; F=$1#$V$EXT
		esac
		[ -n "$N" -o $PKGMK_PACKAGE_DIR/$F -nt $TMP/$P ] || N=n
		shift
	done
	if [ -n "$N" ]; then
		[ $N = y ] || N=${V##*-} V=${V%-[0-9]*}-$((N + 1)) N=y
		Msg build $G/$P\ $V$I
		case $CMD in *b*) NewPackages $* >$LOG 2>&1; >$LOG; esac
	fi
	echo "Pkg $V $L${U:+\n$P#$V.$U}\nSrc $*" >>$TMP/Use
	for F in $L; do
		case "${N:-n} $LST " in
		n*\ $F#$V\ *) continue;;
		*\ $F#*) I=-u;;
		*) I=
		esac
		N=y F=$F#$V$EXT
		Msg pkgadd $I $F
		case $CMD in *b*) pkgadd $I $PKGMK_PACKAGE_DIR/$F; esac
	done
	[ -z "${N:+$U}" ] && return || F=$P#$V.$U
        Msg sh $F
        case $CMD in *b*) sh $PKGMK_PACKAGE_DIR/$F;; esac
}
Who() { # Pkg User Uid [Group Gid] [Home [Comment]]
	case $CMD in ''|*b*) shift;; *) return;; esac
	S=$* N=$1 U=$2
	shift 2
	case $1 in ''|/*) G=$N I=$U;; *) G=$1 I=$2; shift 2;; esac
	[ $# != 0 ] && D=$1 && shift || D=/
	case $(sed "/^$G:/!d;s/.*/1/;q" /etc/group
		sed "/^$N:[^:]*:$U:$I:/!d;s/.*/2/;q" /etc/passwd
		sed "/^$N:/!d;s/.*/3/;q" /etc/shadow) in
	1*2*3);;
	'') Msg @ $S; S=$*; [ -z $CMD ] && return || groupadd -g $I $G
		useradd -u $U -g $G -d $D ${S:+-c "$S"} $N;;
	*) S="'$N' registered with errors"; [ -z $CMD ] && Msg ! $S || End $S!
	esac
}
CheckPackages() {
	LST=$(Lst '.*/')
	for P in $(awk -vL="$LST" '{ N[$1] = NF }
		END { split(L, P); for(n in P) if(N[P[n]] < 2) print P[n] }' $1)
	do
		export LD_LIBRARY_PATH=$(sed "/^$P\s/!d;s/.*\s//" $CFG)
		sed "/^$P$/,/^$/{/\//p};d" $DB |
		while read F; do
			case $F in
			*/|*.[acho]|*.svg|*.gz|*.png|*.hpp|*.pfb|*.xml|*.enc| \
			*.txt|*.cmake|*.p[mcso]|*.[at]fm|*.dtx|*.ui|*.js| \
			*.def|*.ot[ft]|*.dat|*.la|*.conf|*.pod|*.m4|*.html| \
			*.ttf|*.gif|*.mod|*.json|*.jar|*.xsl) continue
			esac
			F=/$F; echo "# $F"
			case $(file -b $F) in
			*ELF*) ldd $F; objdump -p $F | sed -n 's/ NEEDED /-/p';;
			*[Pp]erl*) echo "/usr/bin/perl =>\n- perl";;
			*[Pp]ython*) echo "/usr/bin/python =>\n- python"
			esac
		done 2>/dev/null | awk -vP="$P ${P%-dev}" '
		{
			if($1 == "#") L[$2] = 0
			else if($1 == "-") N[$2] = 0
			else if($3 ~ /\//) U[$3] = $3
			else if($2 == "=>") U[$1] = $1
		}
		END {
			asort(U)
			for(n in U) {
				l = n = U[n]; sub(/.*\//, "", n)
				if(n in N) if(!(l in L)) P = P " " l
			}
			print P
		}'
	done >>$1
	awk -vL="$LST" '{
		while(gsub(" /lib64/", " /lib/")+gsub(/\/[^/]+\/\.\.\//, "/"));
		S[$1] = $0
		} END { split(L, P); for(n in P) print S[P[n]] }' $1
}
CreateUse() {
	{
	sed -n '/^$/d;/^lib64$/d;/\//{s%^%/%;/\.so\./p;/\.so$/p
		/^\/usr\/bin\/perl$/p;/^\/usr\/bin\/python$/p;d}
		N;s%\n% %;s%^%= %p' $DB
	sed '/^[ \t]*\(#.*\)*$/d
		:L /[ \t][ \t]*\\$/{N;b L};s/[ \t][ \t]*\\\n/ /g
		s/[ \t]*#.*//;s/[ \t][ \t]*/ /g;/^[A-Z]/!d' $CFG
	} | awk 'BEGIN { Val[Ord[++c] = "ALL"] = "0" }
	function All(n) { Dep["ALL"] = Dep["ALL"] " " n }
	function Reg(i) { if(!(i in u)) l = l Dep[u[i] = i] }
	function Err(s) { E++; print "\t" s >"/dev/stderr" }
	function Out(n) {
		if(n in Who) print Who[n]
		print n "#" Val[n] Dep[n]
		if(n in Run) print Run[n]
		delete Val[n]
	}
	/^\// { Lib[$1] = n; next }
	/^=/ { Val[Ord[++c] = n = $2] = $3; All(n); next }
	/^Pkg/ { G[$2] = G[$2] " " $4; if(/ -[^ ]*r /) Run[$4] = "+ " $4; next }
	/^Who/ { $1 = "@"; Who[$2] = $0; next }
	/^[A-Z]/ {
		n = $1; delete u; Val[Ord[++c] = n] = "0"
		for(i = 1; i++ < NF;)
			if($i in Val) u[$i] = 0; else P[$i] = P[$i] " " n
		delete u[n]; for(i in u) { Dep[n] = Dep[n] " " i; Req[i]++ }
		next
	}
	{
		n = $1; delete u; u["filesystem"] = 0
		if($2 in Val) u[$2] = 0; else P[$2] = P[$2] " " n
		for(i = 2; i++ < NF;)
			if(Lib[$i]) u[Lib[$i]] = 0; else U[$i] = U[$i] " " n
		delete u[n]; for(i in u) { Dep[n] = Dep[n] " " i; Req[i]++ }
	}
	END {
		delete Lib
		for(n in U) {
			Err("missing " n " required by" U[n]); print U[n]
		}
		if(E) exit 1
		for(n in P) Err("missing package " n " required by" P[n])
		for(n in G) {
			split(G[n], a); l = ""
			asort(a); for(i in a) l = l " " a[i]
			Val[Ord[++c] = n = toupper(n)] = "0"
			Grp[n] = Dep[n] = l; All(n)
		}
		delete G
		for(n in Val) {
			split(Dep[n], a); delete s
			for(i in a) s[a[i]] = a[i]
			do {
				l = ""
				for(j in s) {
					delete u; u[n] = l = j
					while(split(l, a)) {
						l = ""; for(i in a) Reg(a[i])
					}
					delete u[j]
					for(i in s) if(i in u) delete s[l = i]
					if(l) break
				}
			} while(l)
			asort(s); for(i in s) l = l " " s[i]; Dep[n] = l
		}
		for(n in Grp) Dep[n] = Grp[n]
		do {
			j = 0
			for(n in Ord) if(Ord[n] in Val) {
				split(Dep[n = Ord[n]], a)
				for(i in a) if(a[i] in Val) { n = 0; break }
				if(n) Out(j = n)
			}
			if(!j) {
				for(i in Val) if(Req[i] > j) j = Req[n = i]
				if(j) Out(n)
			}
		} while(j)
	}' - $TMP/PKG.new $TMP/PKG.ldd
}
#
# Main subroutines
#
ChkDir() { # Dir Var
	S="Value for $2"
	case /$1/ in
	//) Wrn $S must be specified in config;;
	/*//*/|*//|/-*|*/./*|*/../*|*[*?\[\]\'\"\\\	\ ]*)
		Wrn $S has an invalid directory name \'$1\';;
	/[!/]*) Wrn $S must be specified as an absolute path;;
	*)	if [ $1 = $DIR -a -n "$2" ]; then Wrn $S cannot be $1
		else [ -d $1 ] && return || Wrn Directory $1 does not exist
		fi
	esac
	return 1
}
ReadConfig() { # File
	[ -r $1 ] || End Could not read config file $1!
	F=$1
	set -- $(bash -c "name=/./; . $1; echo - \$? -0 \
		- \$PKGMK_SOURCE_DIR -1 - \$PKGMK_PACKAGE_DIR -2 \
		- \$PKGMK_WORK_DIR -3 - \$PKGMK_COMPRESSION_MODE -4")
	for N do
		case $N in
		-1) PKGMK_SOURCE_DIR=$V;;
		-2) PKGMK_PACKAGE_DIR=$V;;
		-3) PKGMK_WORK_DIR=${V%//./};;
		-4) PKGMK_COMPRESSION_MODE=${V:-gz};;
		-0) [ "x$V" = x0 ] || End Runtime error $F!;;
		-) V=;;
		*) V=${V:+$V }$N
		esac
	done
	ChkDir "$PKGMK_SOURCE_DIR" PKGMK_SOURCE_DIR || N=
	ChkDir "$PKGMK_PACKAGE_DIR" PKGMK_PACKAGE_DIR || N=
	ChkDir "$PKGMK_WORK_DIR" PKGMK_WORK_DIR || N=
	case $PKGMK_COMPRESSION_MODE in
	bz2|gz|lz|xz) EXT=.pkg.tar.$PKGMK_COMPRESSION_MODE;;
	*) Wrn "Compression mode '$PKGMK_COMPRESSION_MODE' not supported"; N=
	esac
	[ -n "$N" ] || End Config file $F needs to be changed!
}
GetCollectionsList() {
	UPD= USE= D=${PKGMK_WORK_DIR#$DIR/}
	for F in $DIR/*/*/Pkgfile; do
		F=${F#$DIR/} F=${F%%/*}
		case " $D$USE " in *\ $F\ *);; *) USE=$USE\ $F;; esac
	done
	for D in /etc/ports/drivers/*; do
		[ ! -x $D ] ||
		for F in /etc/ports/*.${D##*/}; do
			F=${F##*/}
			[ "x${F%%.*}" = "x*" ] || UPD=$UPD\ $F
			case " $USE " in *\ ${F%%.*}\ *) continue;; esac
			case $CMD in *u*) continue;; esac
			End Port collections must be updated!
		done
	done
	[ -n "$USE$UPD" ] || End Empty list of port collections!
	case $CMD in *u*);; *) return;; esac
	for F in $NEW; do
		case " $UPD " in *\ $F.*) continue;; esac
		Wrn Unknown update method for collection $F
		CMD=
	done
	[ -n $CMD ]
	Msg Updating the port collections
	for F in $UPD; do
		D=${F#*.} F=${F%%.*}
		case " ${NEW:-$UPD} " in *\ $F[\ .]*)
			Msg collection $F
			/etc/ports/drivers/$D /etc/ports/$F.$D >$LOG 2>&1; >$LOG
		esac
	done
	F=${CMD%u*} CMD=$F${CMD#*u} NEW=
}
EditPatch() {
	for S in $DIR/*/$1/Pkgfile; do
		case $S in $PKGMK_WORK_DIR/*);; *) break;; esac
	done
	[ -f $S ] || End Port $1 not found!
	D=$TMP/$1
	cp $S $D
	if [ -f $WRK/$1 ] && ! patch -fi $WRK/$1 $D >/dev/null; then
		Wrn The rejects detected when applying the patch
		sed '1,2d' $D.rej
		Ask || :
	fi
	case $CMD in
	p) diff -u $S $D && Wrn There is no patch for $S || D=;;
	e) ${EDITOR:-vi} $D; ! diff $S $D >$D~ &&
		Ask Create a patch for $S && S= || D=
	esac
	if [ -z $D ]; then [ -f $WRK/$1 ] && Ask Remove patch for $S || D=y; fi
	if [ -z "$D" -o -z "$S" ]; then
		if [ ! -w $WRK ]; then End Directory $WRK is not writable!
		elif [ -z $S ]; then cp $D~ $WRK/$1
		elif [ -z $D ]; then rm $WRK/$1
		fi
	fi
}
BuildPackages() {
	Msg Creating a list of required packages for building
	PortsList $(Lst '.*/') $NEW | PortsOrder >$TMP/PKG.new ||
	case $? in
	1) End Port collections need to be updated!;;
	2) End Fail to create ports build list!
	esac
	case $CMD in
	*b*)	Msg Build and install packages according to dependencies;;
	*)	Msg View the process of building and installing packages
	esac
	while :; do
		for F in $NEW; do touch $TMP/$F; done
		LST=$(Lst '/#')
		. $TMP/PKG.new
		case $CMD in *b*);; *) return;; esac
		Msg Creating a list of dependencies for packages
		CheckPackages $PKGMK_PACKAGE_DIR/PKG.ldd >$TMP/PKG.ldd
		CreateUse >$TMP/PKG.use && break ||
		Ask Rebuilding and upgrade problematic packages || End
		NEW=$(sed '' $TMP/PKG.use)
	done
	sed -i "1!G;h;\$!d;s/\$/\n$EXT/" $TMP/PKG.use
	cp $TMP/PKG.* $PKGMK_PACKAGE_DIR
}
RmCmd() { Msg rm $1; case $CMD in *b*) rm $1;; esac; }
DeleteUnused() {
	case $CMD in ''|*z*);; *) return;; esac
	echo $PKGMK_SOURCE_DIR/* $PKGMK_PACKAGE_DIR/*#* $WRK/[a-z]* |
	awk -vA=$WRK/ -vE=$EXT -vP=$PKGMK_PACKAGE_DIR/ -vS=$PKGMK_SOURCE_DIR/ '
	/^Pkg/ { F[A $3] = 0; for(i = 2; i++ < NF;) F[P $i "#" $2 E] = 0 }
	/^Src/ { for(i = 1; i++ < NF;) if(sub(/^.+\//, "", $i)) F[S $i] = 0 }
	/^[a-z]/ { F[P $1] = 0 }
	/^\// {
		for(i = 0; i++ < NF;) {
			if((f = $i) ~ "^" A) sub(/#.*/, "", f)
			if(!(f in F || $i ~ /*/)) print "RmCmd " $i
		}
	}' $TMP/Use - >$TMP/Del
	[ -s $TMP/Del ] || return 0
	Msg Removing unused sources, packages and patches
	. $TMP/Del
}
CheckReject() {
	[ -z "$(find /var/lib/pkg/rejected -type f)" ] && return ||
	Wrn Found files rejected during package upgrades
	case $CMD in *b*) ! Ask Run rejmerge || rejmerge;; esac
}
PortsInfo() {
	L="$PKGMK_PACKAGE_DIR/PKG.new $PKGMK_PACKAGE_DIR/PKG.use"
	RequiredFiles $L
	{ sed '/^[a-z]/!d;/\s/d;s/^/Ign /' $CFG; } | awk -vPKG="$NEW" '
	function Set(c,v,p,r) { C[p] = c; V[p] = v; L[p "#" v] = p; R[p] = r }
	function Out(t,l,a,i) {
		if(split(l, a)) {
			print t; asort(a); for(i in a) print "\t\t" a[i]
		}
	}
	/^Pkg/ {
		Set($2, $3, p = $4, "")
		for(i = 4; ++i; ) {
			if($i ~ /^-/) {
				if($i ~ /a/) A[p] = 0
				if($i ~ /p/) P[p] = 0
				if($i ~ /r/) S[p] = 0
				break
			}
			Set($2 "/" p, $3, $i, p)
		}
		sub(/^.*# */, ""); R[p] = $0
		for(i = 0; i++ < NF; ) { N[$i]++; B[$i] = B[$i] " " p }
		next
	}
	/^Who/ { W[$2] = $3; next }
	/^Ign/ { J[$2]++ }
	{
		if(!($1 in L)) next
		p = L[$1]; sub(/^[^ ]* */, ""); U[p] = $0
		if(C[p] ~ /\//) next
		for(i = 0; i++ < NF; ) { J[$i]++; E[$i] = E[$i] " " p }
	}
	END {
		if(split(PKG, L)) {
			asort(L)
			for(n in L) {
				if((p = L[n]) in V)
					e = "\nVersion:\t" V[p] \
						"\nCollection:\t" C[p]
				else
					e = " (not built)"
				print s "Package:\t" p e
				s = "\n"
				if(p in W) print "Need user:\t" W[p]
				if(p in A) print "Add-ons:\tyes"
				if(p in P) print "Patch:\t\tyes"
				if(p in S) print "Post-install:\tyes"
				Out("Requires:", R[p])
				Out("Use:", U[p])
				Out("Required for build:", B[p])
				Out("Required for use:", E[p])
			}
		} else {
			print "Maybe unnecessary ports:"
			for(p in V)
				if(C[p] !~ /\// && !(p in N) && !(p in J))
					a[p] = p
			asort(a); for(i in a) print a[i]
		}
	}' $L -
}
FilesNotInPackages() {
	{
	find $(sed '/^\//!d;s/\s.*$//' $CFG) -mount 2>/dev/null | sed 's%^/%%'
	find / -mount
	} | awk '
	/^\// {
		sub(/^\//, "")
		if($0 in L) delete L[$0]; else L["/" $0] = "/" $0
		next
	}
	/\// {	sub(/\/$/, ""); L[$0] = $0 }
	END {
		delete L["/"]; delete L["/lib64"]
		print "List of files not included in packages:"
		L[0] = "List of missing files included in packages:"
		asort(L); for(p in L) print L[p]
	}' $DB -
}
RequiredFiles() { # File ...
	for F do [ -f $F -a -r $F ] || End Could not read file $F!; done
}
#
# Main
#
export LANG=C
export PATH=/bin:/sbin:/usr/bin:/usr/sbin
export SHELL=/bin/sh
set -e
trap "End Terminated due an error!" 0
trap "End Interrupted by signal!" 1 2 3 13 15
CMD=
LOG=
TMP=
while getopts behilpuz N; do
	case $N in
	h) echo "$NEW"; trap 0; exit;;
	[!beilpuz]) End "\rUsage: pkgnew [-beilpuz] [name ...]"
	esac
	case $CMD$N in
	*$N*$N);;
	[eilp]?|[buz]*[eilp]) End Option -$N incompatibility with -$CMD!;;
	*) CMD=$CMD$N
	esac
done
shift $(($OPTIND - 1))
case $#$CMD in 1[ep]);; *[ep]) End Option -$CMD requires one argument!;; esac
case $CMD in *u*) S=collection;; *) S=port;; esac
for N do
	case -$N- in
	*--*|*[!a-z0-9_+-]*|-[0-9_+]*) End "Invalid $S name '$N'!"
	esac
done
case $CMD in
*[bluz]*) [ $(id -u) = 0 ] || End This can only be done as root!
esac
NEW=$*
for N in $DIR $WRK; do [ -d $N ] || End Directory $N does not exist!; done
RequiredFiles $CFG
ReadConfig /etc/pkgmk.conf
TMP=$(mktemp -dq) || End Unable to create temporary directory!
LOG=$TMP/Log
case $CMD in
[ep])	EditPatch $1;;
i)	PortsInfo;;
l)	FilesNotInPackages;;
*)	GetCollectionsList
	BuildPackages
	DeleteUnused
	CheckReject
esac
End
